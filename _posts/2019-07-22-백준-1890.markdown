---
layout: post
title:  "[백준] 1890 점프"
author: Gyurin
categories: algorithm
tags: dp 백준
---

## 문제
<a href="https://www.acmicpc.net/problem/1890" target="blank">
  <img src="{{ site.baseurl }}/assets/algorithm/BOJ-1890-problem.png" title="[백준] 1890 점프">
</a>

## 아이디어
1. 변수 <br>
    1) `map[r][c]`: input으로 받은 게임판 정보 <br>
    2) `dp[r][c]`: map[r][c]에서 문제의 규칙에 맞게 갈 수 있는 경로의 개수 <br><br>
    => `dp[0][0]`이 정답이 된다.

2. 알고리즘<br>
    반드시 오른쪽 또는 아래쪽으로 이동해야 하므로, `map[r][c]`의 값이 `j`일때<br> `map[r][c]`에서 갈 수 있는 곳은 `map[r+j][c]` 또는 `map[r][c+j]` 2 곳이다. <br>
    즉, 경로의 개수는 `dp[r][c] = dp[r+j][c] + dp[r][c+j]`가 된다. 

    DP를 이용하기 위해, `dp[r][c]`를 -1로 초기화하였다.<br>
    `dp[r][c]`가 -1이 아니라면, 이미 계산된 값이므로 값을 참조하고 그렇지 않다면 재귀함수 호출을 이용해 값을 계산해준다.
    이 때, `j`가 0이면, 이동할 수 없기 때문에 바로 `dp[r][c]=0` 처리를 해준다. 

3. 오답노트<br>
    이 문제는 메모리 초과 문제로 고생했다. N의 최댓값이 100이기 때문에 `map[r][c]`이나 `dp[r][c]`의 크기 자체는 별로 문제가 되지 않았지만 메모리가 계속 터졌다.<br>
    <b>결론적으론, `dp[r][c]`의 type을 잘못 정해주어서 메모리가 터졌다.</b><br>
    주어진 문제를 보면, '경로의 개수는 2<sup>63</sup>-1보다 작거나 같다.'라고 명시되어 있다. ~~저 부분에서 경로의 개수의 type으로 int는 턱없이 부족하다는 걸 캐치했어야 헀다.~~ 그래서 `dp[r][c]`의 타입을 넉넉하게 `long long int`로 바꿔주었다. 또한 출력 스트림 역시 `cout`에서 `printf`로 바꿔주었다. <br>
    두 번째로는, 자료형을 바꿔줄 때 ~~바보같이~~ `dp[r][c]`만 바꿔주고, 그 값을 담는 tmp 변수의 자료형은 바꾸지 않고 그대로 `int`로 두었다. 그래서 값이 잘리게 되어 틀렸다.


## 코드

{% highlight C++ linenos=table %}
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;

const int MAX = 100;
int N;
int map[MAX][MAX];
long long int dp[MAX][MAX];

long long int func(int r, int c){

    if(dp[r][c]!=-1) return dp[r][c];

    int j = map[r][c];
    if(j==0){
        dp[r][c] = 0;
        return dp[r][c];
    }

    long long int tmp =0;
    if(r+j<N){
        if(dp[r+j][c]!=-1)
            tmp += dp[r+j][c];    
        else
            tmp += func(r+j, c);
    }
    if(c+j<N){
        if(dp[r][c+j]!=-1)
            tmp += dp[r][c+j];  
        else
            tmp += func(r, c+j);
    }
    dp[r][c] = tmp;
    return dp[r][c];

}

int main(){
    memset(dp, -1, sizeof(dp));
    scanf("%d", &N);

    for(int r=0; r<N; r++){
        for(int c=0; c<N; c++){
            scanf("%d", &map[r][c]);

        }
    }
    dp[N-1][N-1] = 1;

    func(0, 0);

    printf("%lli\n", dp[0][0]);
  
    return 0;
}
{% endhighlight %}

## 결과
<img src="{{site.baseurl}}/assets/algorithm/BOJ-1890-result.png" title="[백준] 1890 점프">

## 참고
<a href="https://www.quora.com/What-are-the-sizes-and-ranges-of-int-long-int-long-long-int-and-unsigned-long-long-int-in-C-Is-there-any-other-data-type-that-can-store-greater-than-unsigned-long-long-int"> long long int의 크기 </a>