---
layout: post
title:  "[백준] 14502 연구소"
author: Gyurin
categories: algorithm
tags: DFS BFS 백준
---


## 문제
<a href="https://www.acmicpc.net/problem/14502" target="blank">
  <img src="{{site.baseurl}}/assets/algorithm/BOJ-14502-problem.png" title="[백준] 14502 연구소">
</a>

## 아이디어
이 문제는 코딩 테스트 준비하면서 3번째로 풀었던 문제이다. ~~[백준] 1260번을 수도코드 보고 풀 때 였다.(힘듦)~~ 탐색 응용 첫 문제이기도 했고 ~~구구절절~~ map같은 2d에서 현재 위치 이후 탐색(이 문제의 경우 벽세우기) 방법에 효율성도 없어 무한루프가 돌기도 하고 시간이 오래걸리기도 했다. 또한, 바이러스를 퍼트리는 과정에서도 분명 알고리즘 다 맞고, 기본 테케와 게시판의 추가 테케도 다 맞는데, 자꾸 틀렸다고 나와서 고생했었다.<br>
오늘 다시 풀어봤을 때는, 그새 좀 경험치가 쌓였는지 40분만에 풀었다.(야호!)<br><br>

1. 변수 <br>
`int map[MAX][MAX]`: 입력으로 받는 연구소의 정보이다. 또한 추가로 벽을 세우기도 한다.<br>
`vector<pair<int, int> > v`: 초기 바이러스 위치들을 저장한다.<br><br>

2. 알고리즘<br>
    1) result 계산하는 법<br>
        : 처음 이 문제를 풀 때는, 전체 연구소 크기에서 벽의 개수와 바이러스 개수를 빼줬다. 하지만 이번에는 빈 공간 개수에서 퍼진 바이러스 개수와 추가로 세운 벽 3개를 빼는 방법을 택했다. 이를 위해 퍼진 바이러스의 개수를 세주었다. `res = #empty - #퍼진바이러스 - 3(추가로 세운 벽)` <br><br>

    2) 벽 세우기<br>
        : `void wall(int R, int C, int cnt)`에서 진행된다.<br>
        벽을 세울 수 있는 모든 경우에 대해 바이러스를 퍼트려 안전 영역이 가장 넓은 경우를 찾는다.<br>
        R과 C는 벽 세울 곳 탐색 시작 위치(방금 세운 벽의 위치), cnt는 현재까지 세운 벽의 개수이다.<br>
        main함수에서 `wall(0, 0, 0)`을 호출하며 문제를 해결한다.<br><br>
        추가로 세우는 벽은, 파라미터로 받은 (R, C)부터 벽을 세울 수 있는지 탐색한다. 처음에는 매개변수로 cnt만 넘겨주어, (0, 0) 부터 빈 공간을 찾았더니, 이미 시도해 보았던 곳에 벽을 다시 세우게 되어 무한루프가 되었다. ex) 1, 2, 3 위치에 벽을 세웠다가 다시 1, 3, 2에 벽을 세우게 됨.<br>
        0(빈 공간)이라면 벽을 세우고, 재귀로 `wall`을 다시 호출한다. 재귀에서 돌아오면 벽을 없애고 다음 칸으로 넘어가 새로운 경우로 넘어간다.<br>
        벽 3개를 모두 세웠다면, 바이러스를 확산시켜 
        
    3) 바이러스 확산<br>
        : `int virus()`에서 진행된다. 퍼진 바이러스 개수를 return한다.<br>
        탐색은 BFS를 이용했으며 DFS 또한 가능하다. ~~나중에 다시 풀 때는 DFS로 풀어보려 한다.~~<br>
        탐색을 위한 큐와 방문정보를 매 경우마다 초기화하기 싫어서 `virus`함수 안에 선언해 주었다. 하지만, vst의 경우 초기화를 안해주었더니, 제대로 탐색을 하지 못해 `memset`을 이용해 false로 초기화했다.<br>
        BFS로 바이러스를 퍼뜨릴 때, '벽이 아닌 곳'에 퍼뜨려도 되지만, <b>'퍼진 바이러스 개수'</b>만 카운트하기 위해, '빈 공간'에만 바이러스를 퍼뜨렸다.<br><br>


## 코드

{% highlight C++ linenos=table %}
#include <iostream>
#include <vector>
#include <queue>
#include <cstring>
using namespace std;

const int MAX = 8;
int N, M, res=MAX*MAX;
int map[MAX][MAX];
vector<pair<int, int> > v;

int virus(){
    int ret=0;
    bool vst[MAX][MAX];
    queue<pair<int, int> > q;
    
    memset(vst, false, sizeof(vst));
    for(int i=0; i<v.size(); i++){
        q.push(v[i]);
        vst[v[i].first][v[i].second] = true;
    }

    while(!q.empty()){
        pair<int, int> u = q.front();   q.pop();

        int dr[4] = {1, -1, 0, 0};
        int dc[4] = {0, 0, 1, -1};
        for(int d=0; d<4; d++){
            int nr = u.first + dr[d];
            int nc = u.second + dc[d];

            if(nr<0 || nr>=N || nc<0 || nc>=M)  continue;

            if(!vst[nr][nc] && map[nr][nc]==0){
                vst[nr][nc] = true;
                q.push(make_pair(nr, nc));
                ret++;
            }
        }
    }

    return ret;
}

void wall(int R, int C, int cnt){

    if(cnt==3){
        int tmp = virus();
        if(tmp<res){
            res = tmp;
        }
        return;
    }

    for(int r=R; r<N; r++){
        for(int c=0; c<M; c++){
            if(r==R && c<C) continue;

            if(map[r][c]==0){
                map[r][c] = 1;
                wall(r, c, cnt+1);
                map[r][c] = 0;
            }
        }
    }
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(NULL);  cout.tie(NULL);
    
    cin >> N >> M;
    int num=0;
    for(int r=0; r<N; r++){
        for(int c=0; c<M; c++){
            cin >> map[r][c];

            if(map[r][c]==2)
                v.push_back(make_pair(r, c));

            if(map[r][c]==0)
                num++;

        }
    }

    wall(0, 0, 0);
    cout << num - res - 3 << "\n";
    return 0;
}
{% endhighlight %}

## 결과
<img src="{{site.baseurl}}/assets/algorithm/BOJ-14502-result.png" title="[백준] 14502 연구소">

## 참고