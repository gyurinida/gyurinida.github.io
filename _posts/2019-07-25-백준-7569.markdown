---
layout: post
title:  "[백준] 7569 토마토"
author: Gyurin
categories: algorithm
tags: BFS 백준
---


## 문제
<a href="https://www.acmicpc.net/problem/7569" target="blank">
  <img src="{{site.baseurl}}/assets/algorithm/BOJ-7569-problem.png" title="[백준] 7569 토마토">
</a>

## 아이디어
탐색을 3차원으로 진행하면 된다. 대부분의 탐색문제는 2차원에서 진행되었는데, 이번엔 3차원이다. 2차원에서는 상하좌우 4가지 방향에 대해 탐색했다면, 3차원은 위아래를 추가해 6가지 방향을 탐색하면 된다. ~~2차원과 별반 다르지 않다.~~<br><br>
우선, 토마토를 익히기 위해서는 <b>DFS가 아닌 BFS를 사용</b>해야 한다. 익은 토마토들을 기준으로 점점 퍼져나가게 되는 것이므로 BFS로 진행해야 한다. <b>모두 익는 데 걸리는 시간은 BFS의 최고 depth</b>가 된다. 이 때 depth를 측정하는 방법은 3가지 정도가 있는데 이는 마지막에 간단히 소개하겠다.

1. 변수 <br>
    `struct pos = {r, c, h}`: 3차원의 좌표를 담는 구조체이다.<br>
    `int ttn`: 안 익은 토마토의 갯수(total num)이다. 탐색을 끝낸 후에도 익지 않은 토마토가 남아있다면 불가능한 경우이므로 -1을 return한다.<br><br>

2. 알고리즘<br>
    1) 입력처리<br>
        : 입력을 받으면서, 이미 익은 토마토들은 방문처리를 해주고, 큐에 추가해둔다.<br>
    2) `int func()`<br>
        : BFS로 탐색하여 토마토를 익히고, 모두 익게된다면 걸린 시간, 그렇지 않다면 -1을 return한다.<br><br>

## 코드
{% highlight c++ linenos=table %}
    #include <iostream>
    #include <queue>
    using namespace std;

    struct pos{
        int r, c, h;
    };

    const int MAX = 100;
    int M, N, H;
    int map[MAX][MAX][MAX];
    bool vst[MAX][MAX][MAX];
    queue<pos> q;
    int ttn=0;

    int func(){
        int dr[6] = {1, -1, 0, 0, 0, 0};
        int dc[6] = {0, 0, 1, -1, 0, 0};
        int dh[6] = {0, 0, 0, 0, 1, -1};
        
        int depth=-1;
        while(!q.empty()){
            depth++;
            int s = q.size();
            for(int a=0; a<s; a++){
                pos u = q.front();  q.pop();

                for(int i=0; i<6; i++){
                    int nr = u.r + dr[i];
                    int nc = u.c + dc[i];
                    int nh = u.h + dh[i];

                    if(nr<0 || nr>=N || nc<0 || nc>=M || nh<0 || nh>=H) continue;

                    if(!vst[nr][nc][nh] && map[nr][nc][nh]==0){
                        vst[nr][nc][nh] = true;
                        pos pp = {nr, nc, nh};
                        q.push(pp);
                        ttn--;
                    }
                }
            }
        }
        
        if(ttn!=0)  return -1;
        else    return depth;
    }

    int main(){
        ios::sync_with_stdio(false);
        cin.tie(NULL);  cout.tie(NULL);

        cin >> M >> N >> H;
        for(int h=0; h<H; h++){
            for(int r=0; r<N; r++){
                for(int c=0; c<M; c++){
                    cin >> map[r][c][h];

                    if(map[r][c][h]==1){
                        pos p = {r, c, h};
                        q.push(p);
                        vst[r][c][h]= true;
                    }
                    if(map[r][c][h]==0)    ttn++;
                }
            }
        }

        cout << func() << "\n";
        return 0;
    }
{% endhighlight %}

<br>

## 결과
<img src="{{site.baseurl}}/assets/algorithm/BOJ-7569-result.png" title="[백준] 7569 토마토"><br><br>

## BFS의 depth를 카운트하는 법
주로 1)을 사용하고, 최고 depth 말고도 정보가 필요하다면 3)을 이용한다.

1) 초기 큐의 크기의 반복문을 이용<br>
    : 우선 2가지 변수가 필요하다. `depth`(깊이)와 `size`(부분 반복문의 크기).<br>
    탐색 중인 정점의 depth가 달라지면 depth를 증가시켜준다. depth가 달라지는 시점을 알기 위해 while문 안에 반복문을 하나 더 추가해준다. <b>while문의 맨 처음에, 현재 큐의 사이즈를 size에 담아 그만큼 반복문을 진행</b>하면, 같은 depth의 정점들만 탐색하게 된다. 이 <b>반복문이 끝나면 depth를 증가</b>시켜준다.
    BFS는 queue을 이용하여 탐색을 진행하는데, 탐색한 정점은 pop, 새로 방문할 곳은 push하므로 큐의 크기는 계속 변하기 때문에 큐의 사이즈를 따로 저장하여 그만큼만 반복문을 돌려줘야 한다.
    
{% highlight c++ linenos=table %}
    void bfs(int start){
        queue<int> q;   q.push(start);

        int depth = 0;
        while(!q.empty()){
            depth++;
            int size = q.size();

            // 같은 깊이의 정점들에 대한 탐색
            for(int s=0; s<size; s++){
                int cur = q.front();    q.pop();

                // ...
                // cur과 연결된 곳들에 대해
                // 방문 안 했다면, 큐에 추가
                // ... 
            }
        }

        return depth;
    }
{% endhighlight %}    

2) 2개의 flag를 이용<br>
    : 이 방법은 1번과 같은 원리이며, depth가 달라지는 시점을 확인하기 위한 구현이 다를뿐이다. 이런 문제를 처음 만났을 때  어떻게 하면 BFS의 depth를 알 수 있을까 고민하다가 생각한 방법이다. ~~그래서 굉장히 raw한 아이디어..~~<br>
    3가지 변수가 필요하다. `depth`(깊이), `flag`(현재 depth의 정점 개수), `next_flag`(다음 depth의 정점 개수).<br>
    flag는 1)에서 size변수와 같은 역할을 하고, next_flag는 다음 depth의 정점 개수를 알기 위해 큐에 push될 때 증가시켜준다.

{% highlight c++ linenos=table %}
    void bfs(int start){
        queue<int> q;   q.push(start);
        int flag = q.size();
        int next_flag = 0;

        int depth = 0;
        while(!q.empty()){
            
            if(flag == 0){
                depth++;
                flag = next_flag;
                next_flag = 0;
            }
            flag--;

            int cur = q.front();    q.pop();
            
            // ...
            // cur과 연결된 곳들에 대해
                if(!vst[next]){
                    vst[next] = true;
                    next_flag++;
                    q.push(bext);
                }
            // ...
        }

        return depth;
    }
        
{% endhighlight %}

3) vst변수를 이용<br>
    : 이 방법은 위의 방법들과 다른 방식이다. `depth`(깊이)와 기존의 visited 변수를 활용한다.<br>
    일반적으로 방문정보를 담는 변수는 bool로 지정해주는데, int로 지정해주면 depth를 확인할 수 있다. 최고 깊이뿐만 아니라, 모든 정점들에 대한 depth도 알 수 있다.(단, 이는 탐색 시작 위치에 달라지므로 주의해야 한다.) 방문처리를 해줄 때 `vst[nr][nc] = true`가 아닌 `vst[nr][nc] = depth`로 해주면 된다.
    
{% highlight c++ linenos=table %}
    void bfs(int start){
        queue<int> q;   q.push(start);

        int depth = 0;
        while(!q.empty()){
            depth++;

            int cur = q.front();    q.pop();

            // ...
            // cur과 연결된 곳들에 대해
                if(vst[next]==0){
                    vst[next] = depth;
                    q.push(bext);
                }
            // ... 
        }

        return depth;
    }

{% endhighlight %}

