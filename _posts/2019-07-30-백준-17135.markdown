---
layout: post
title:  "[백준] 17135 캐슬디펜스"
author: Gyurin
categories: algorithm
tags: 시뮬레이션 BFS 백준
---


## 문제
<a href="https://www.acmicpc.net/problem/17135" target="blank">
  <img src="{{site.baseurl}}/assets/algorithm/BOJ-17135-problem.png" title="[백준] 17135 캐슬디펜스">
</a>

## 아이디어
40분 소요. 조합 + 시뮬레이션 문제다. 조합으로 모든 경우를 뽑은 방법은 외워놔야 겠다.<br>

1. 변수 <br>
    `int enemy`: 총 적의 숫자.<br>
    `int map[MAX][MAX]`: 맵의 정보. (0:빈 칸  1: 적  2: 타겟  3: 죽음)<br>
    `bool vst[MAX][MAX]`: 적을 찾을 때 쓰기 위한 방문정보 <br>
    `vector<int> arch`: 궁수들의 column 정보<br>
    `queue<pair<int, int> > enm`: 이번 turn에서 죽인 적들의 위치 정보<br>
    `int tmp, res`; res는 결과. tmp는 res를 찾기 위해 임시로 사용하는 변수<br>

2. 알고리즘<br>
    1) 궁수들 위치 선정: 조합(<sub>M</sub>C<sub>3</sub>)<br>
        `void cmbn(int last)`<br>
        : 가능한 모든 궁수들 위치에 대해 게임을 진행해 결과를 비교해야 한다. 재귀로 조합을 구현한다.<br>
        argument인 `last`는 직전에 궁수를 세운 위치+1로, 남은 궁수는 `last`부터 세우면 된다.<br>
        3명을 다 세우면, `play()`를 호출해 시뮬레이션 결과를 확인한다.

    2) 게임 진행 ①: 매 turn마다 적들이 다가옴<br>
        `void play()`<br>
        : 매 turn 마다 적들이 한 칸씩 다가와야 하지만 이를 처리해주기는 번거로우므로 궁수들의 row를 한 줄씩 위로 올린다. 즉, 궁수들이 누구를 쏠지 적 탐색을 할 때, 시작 위치의 row를 바꿔주면 된다. 이는 반복문을 이용해 궁수들의 row정보를 N-1부터 0까지 바꿔주며 진행하고, 각 turn마다 `shoot(row)`을 이용해 활을 쏜다.<br>

    3) 게임 진행 ②: 화살 쏘기<br>
        `void shoot(int ROW)`<br>
        : 궁수들이 ROW행에 있을 때.<br>
        사정거리 안에 적이 여러 명 있을 경우, 가장 가까운 적, 가장 왼쪽에 있는 적이 우선순위이다.<br>
        각 depth마다(이므로 BFS를 이용) 왼쪽(←), 앞(↑), 오른쪽(→)으로 탐색을 진행한다. 살아있는 적을 발견하면(1 또는 2) 타겟팅 된 상태(2)로 바꿔주고 탐색을 종료한다. 새로 타겟팅 된 적들(1이었던 적)은 `tmp`를 증가시켜 죽일 수 있는 적의 수를 카운트하고, `enm`이란 큐에 위치를 넣어준다.(큐는 ④에서 사용된다.) 적을 바로 죽이지 않고 타겟팅 상태로 두는 이유는, 서로 다른 궁수가 같은 적에게 활을 쏠 수 있기 때문이다. 죽이는 처리는 ③에서 진행한다. depth는 최대 사정거리인 D까지만 탐색한다.<br>

    4) 게임 진행 ③: 적 처리<br>
        `void play()`<br>
        : `enm`을 이용하여 각 turn에 타겟이 되었던 적(2)들을 죽은 상태(3)로 바꿔준다. 0으로 바꾸지 않는 이유는, 모든 조합의 경우에 대해 시뮬레이션을 하므로 매 경우마다 맵을 처음 상태로 돌려줘야하기 때문이다. 이때 죽인 적을 0으로 바꾸면 초기화할 수 가 없어서 3으로 두었다.<br>

    5) 게임 진행 ④: 맵 초기화<br>
        `void play()`<br>
        : 적을 다 죽였든, 모든 turn을 다 진행했든 시뮬레이션이 끝나면 맵을 초기화 해준다. 0이 아닌 모든 곳(1, 2, 3)을 1로 바꿔주면 된다.<br>

    
## 코드
{% highlight c++ linenos=table %}
    #include <iostream>
    #include <queue>
    #include <cstring>
    #include <vector>
    using namespace std;

    const int MAX = 15;
    int N, M, D, enemy=0;
    int map[MAX][MAX];  // 0:빈 칸  1: 적  2: 타겟  3: 죽음
    bool vst[MAX][MAX];
    vector<int> arch;
    queue<pair<int, int> > enm;
    int tmp=0, res=0;

    void shoot(int ROW){
        int dr[3] = {0, -1, 0};
        int dc[3] = {-1, 0, 1};
        for(int a=0; a<arch.size(); a++){
            memset(vst, false, sizeof(vst));

            // 적 탐색
            int depth=0;
            bool flag = false;
            queue<pair<int, int> > q;   q.push(make_pair(ROW-1, arch[a]));
            while(!q.empty()){
                if(depth == D)  break;
                depth++;
                int size = q.size();
                for(int s=0; s<size; s++){

                    pair<int, int> u = q.front();   q.pop();

                    if(map[u.first][u.second]==1 || map[u.first][u.second]==2){
                        if(map[u.first][u.second]==1){
                            tmp++;
                            map[u.first][u.second] = 2;
                            enm.push(make_pair(u.first, u.second));
                        }
                        flag = true;
                        break;
                    }

                    for(int i=0; i<3; i++){
                        int nr = u.first + dr[i];
                        int nc = u.second + dc[i];

                        if(nr<0 || nr>=N || nc<0 || nc>=M)  continue;

                        if(!vst[nr][nc]){
                            vst[nr][nc] = true;
                            q.push(make_pair(nr, nc));
                        }
                    }
                }
                if(flag)    break;
            }

        }
    }

    void play(){
        tmp = 0;
        for(int row=N; row>0; row--){
            shoot(row);
            if(tmp==enemy)  break;

            // 타겟이었던 적 처리
            while(!enm.empty()){
                pair<int, int> u = enm.front(); enm.pop();
                map[u.first][u.second] = 3;
            }
        }

        // 맵 초기화
        for(int r=0; r<N; r++)
            for(int c=0; c<M; c++)
                if(map[r][c] != 0)
                    map[r][c] = 1;
    }

    void cmbn(int last){

        if(arch.size() == 3){
            play();
            if(tmp>res){
                res = tmp;
            }
            return;
        }

        for(int i=last; i<M; i++){
            arch.push_back(i);
            cmbn(i+1);
            arch.pop_back();
        }
    }

    int main(){
        ios::sync_with_stdio(false);
        cin.tie(NULL);  cout.tie(NULL);

        cin >> N >> M >> D;
        for(int r=0; r<N; r++){
            for(int c=0; c<M; c++){
                cin >> map[r][c];

                if(map[r][c]==1)
                    enemy++;
            }
        }

        cmbn(0);
        cout << res << "\n";
        return 0;
    }
{% endhighlight %}

## 결과
<img src="{{site.baseurl}}/assets/algorithm/BOJ-17135-result.png" title="[백준] 17135 캐슬디펜스"><br><br>
