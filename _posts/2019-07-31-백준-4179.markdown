---
layout: post
title:  "[백준] 4179 불!"
author: Gyurin
categories: algorithm
tags: BFS DFS 백준
---


## 문제
<a href="https://www.acmicpc.net/problem/4179" target="blank">
  <img src="{{site.baseurl}}/assets/algorithm/BOJ-4179-problem.png" title="[백준] 4179 불!">
</a>

## 아이디어
40분 소요. BFS 또는 DFS로 해결할 수 있고 나의 경우 BFS로 해결했다. ~~재귀 안쓰는 BFS 짱 좋아..~~ 지훈이에 초점을 맞춰 BFS를 진행하되, 각 depth마다 불도 퍼뜨려준다. 지훈이는 불이 새로 번진 곳으로 이동하면 안되므로, 불을 먼저 퍼뜨려주고, 지훈이를 움직인다.<br>
문제 풀면서 생각한 다른 방법으로는, 시간에 따른 불이 퍼지는 곳은 항상 일정하므로, 몇 depth 후에 불이 붙는지를 먼저 계산해놓고, 이 정보를 바탕으로 지훈이만 움직여도 될 것 같다. BFS에서 depth를 재는 방법들 중 vst변수를 이용하는게 있었다. (<a href="{{site.baseurl}}/algorithm/2019/07/25/백준-7569.html" target="blank">[백준] 7569 토마토</a> 포스트 참고) 이를 이용해서 불이 번지는 시점을 미리 알아 놓고 지훈이의 현재 depth와 비교하여 움직이면 될 것 같다.<br>

1. 변수 <br>
    `pair<int, int> J`: 지훈이의 초기 위치.<br>
    `queue<pair<int, int> > q, qF`: 각각 지훈이, 불을 위한 큐<br>

2. 알고리즘<br>
    1) 지훈이 depth에 맞춰 불을 퍼트린다. '.'이거나 'J'이면 불 번짐.<br>
    2) 지훈이는 현재 위치가 가장자리이면 탈출한다. 그렇지 않으면 불을 피해 이동한다. '.'이면 이동. <br>
        탈출 조건은 현재위치에 대해 확인해주었다. 원래는 탐색을 하면서 큐에 넣기 전에 탈출여부를 확인했는데, 그랬더니 초기 위치가 바로 탈출가능한 위치였을 경우를 커버하지 못했다. 예를 들어 다음과 같은 경우이다.<br>
        &nbsp;2 2<br>&nbsp;J F<br>&nbsp;F F<br>
        본격적으로 bfs 전에 초기 위치가 탈출 가능한지 확인하고 진행하던가, 아니면 큐에서 pop했을 때 탈출 가능한지를 확인하면 저런 경우도 커버할 수 있다.<br>

    
## 코드
{% highlight c++ linenos=table %}
    #include <iostream>
    #include <queue>
    using namespace std;

    const int MAX = 1001;
    int R, C;
    char map[MAX][MAX];
    bool vst[MAX][MAX];
    pair<int, int> J;
    queue<pair<int, int> > q, qF;

    int bfs(){
        int dr[4] = {1, -1, 0, 0};
        int dc[4] = {0, 0, 1, -1};

        int ret=0;
        while(!q.empty()){
            ret++;

            // 불
            int fsize = qF.size();
            for(int fs=0; fs<fsize; fs++){
                pair<int, int> u = qF.front();  qF.pop();
                for(int i=0; i<4; i++){
                    int nr = u.first + dr[i];
                    int nc = u.second + dc[i];

                    if(nr<0 || nr>=R || nc<0 || nc>=C)  continue;

                    if(map[nr][nc]=='.' || map[nr][nc]=='J'){
                        map[nr][nc] = 'F';
                        qF.push(make_pair(nr, nc));
                    }
                }

            }
            
            // 지훈이
            int size = q.size();
            for(int s=0; s<size; s++){
                pair<int, int> u =q.front();    q.pop();

                // 탈출
                if(u.first==0 || u.first==R-1 || u.second==0 || u.second==C-1)
                    return ret;

                for(int i=0; i<4; i++){
                    int nr = u.first + dr[i];
                    int nc = u.second + dc[i];

                    if(nr<0 || nr>=R || nc<0 || nc>=C)  continue;

                    if(!vst[nr][nc] && map[nr][nc]=='.'){

                        vst[nr][nc] = true;
                        q.push(make_pair(nr, nc));
                    }
                }
            }
        }

        return -1;
    }

    int main(){
        ios::sync_with_stdio(false);
        cin.tie(NULL); cout.tie(NULL);

        cin >> R >> C;
        for(int r=0; r<R; r++){
            for(int c=0; c<C; c++){
                cin >> map[r][c];

                if(map[r][c]=='J'){
                    J = make_pair(r, c);
                    vst[r][c] = true;
                    q.push(J);
                }

                if(map[r][c]=='F'){
                    qF.push(make_pair(r, c));
                }
            }
        }

        int res = bfs();
        if(res==-1)
            cout << "IMPOSSIBLE\n";
        else
            cout << res << "\n";
        return 0;
    }
{% endhighlight %}

## 결과
<img src="{{site.baseurl}}/assets/algorithm/BOJ-4179-result.png" title="[백준] 4179 불!"><br><br>
