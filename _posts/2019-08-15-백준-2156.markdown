---
layout: post
title:  "[백준] 2156 포도주 시식"
author: Gyurin
categories: algorithm
tags: dp 백준
---


## 문제
<a href="https://www.acmicpc.net/problem/2156" target="blank">
  <img src="{{site.baseurl}}/assets/algorithm/BOJ-2156-problem.png" title="[백준] 2156 포도주 시식">
</a>

## 아이디어
1. 변수 <br>
    `int wine[MAX]`: 압력으로 받은 포도주의 양.<br>
    `int dp[n][4]`: n번쨰 와인에 대한 dp 값.<br>
        &nbsp;&nbsp;&nbsp;&nbsp;`int dp[n][0]`: n번째를 안 마셨을 때 최대 포도주의 양.<br>
        &nbsp;&nbsp;&nbsp;&nbsp;`int dp[n][1]`: n번째를 마셨고, n-1번째를 안마셨을 때 최대 포도주의 양.<br>
        &nbsp;&nbsp;&nbsp;&nbsp;`int dp[n][2]`: n번째를 마셨고, n-1번째도 마셨을 때 최대 포도주의 양.<br>
        &nbsp;&nbsp;&nbsp;&nbsp;`int dp[n][3]`: [0], [1], [2] 중 최대값. 점화식에서 이전 인덱스의 최대값을 계속 계산하기 때문에, 아예 열을 추가해 값을 저장하였다.<br>

2. 알고리즘<br>
    처음에는 dp의 가장 전형적인 문제 중 하나인 계단 오르기 문제와 유사하다는 생각을 하며 풀었다. 그래서 직전의 포도주를 마셨을 때와 마시지 않았을 때 2가지 경우만을 나누었다. 하지만, 이 문제의 경우 그에 해당하지 않는 경우가 있다. 바로 <b>현재의 포도주를 마시지 않는 경우</b>이다.<br>
    계단 오르기 문제는, 반드시 마지막 계단을 밟아야 하므로, dp를 구현할 때 현재의 경우는 항상 포함하는 걸로 생각하면 끝이었다. 포도주는 마지막 포도주를 반드시 마실 필요가 없으므로, 현재를 마시지 않는 경우도 고려해줘야 한다.<br>
    이는, 다음 <a href="https://www.acmicpc.net/board/view/39482" target="blank">테스트케이스</a>로 확인할 수 있다. 올바른 답은 20(2+1+8+9)지만, 현재 포도주를 마시는 경우를 고려하지 않아 19가 나왔다.<br>
    6<br>   2 1 0 0 8 9<br>
    
    1) base case<br>
        0번째와 1번째에 대해서 초기화를 해주면 된다.<br><br>
    2) 점화식<br>
        `dp[n][0] = max(dp[n-1]);`<br>
        `dp[n][1] = wine[n] + max(dp[n-2]);`<br>
        `dp[n][2] = wine[n] + dp[n-1][1];`<br>


## 코드
{% highlight c++ linenos=table %}
    #include <iostream>
    using namespace std;

    const int MAX = 10000;
    int N;
    int wine[MAX];
    int dp[MAX][4];

    int main(){
        ios::sync_with_stdio(false);
        cin.tie(NULL);  cout.tie(NULL);

        cin >> N;
        for(int i=0; i<N; i++){
            cin >> wine[i];
        }

        dp[0][0]=0;         dp[0][1]=wine[0];   dp[0][2]=wine[0];   dp[0][3]=wine[0];
        dp[1][0]=wine[0];   dp[1][1]=wine[1];   dp[1][2]=wine[0]+wine[1];   dp[1][3]=dp[1][2];

        int res=max(dp[0][3], dp[1][3]);
        for(int i=2; i<N; i++){
            dp[i][0] = dp[i-1][3];
            dp[i][1] = dp[i-2][3] + wine[i];
            dp[i][2] = dp[i-1][1] + wine[i];
            dp[i][3] = max(max(dp[i][0], dp[i][1]), dp[i][2]);
            
            if(res<dp[i][3])
                res = dp[i][3];
        }

        cout << res << "\n";
        return 0;
    }
{% endhighlight %}

## 결과
<img src="{{site.baseurl}}/assets/algorithm/BOJ-2156-result.png" title="[백준] 2156 포도주 시식"><br><br>
