---
layout: post
title:  "[백준] 11053 가장 긴 증가하는 부분 수열"
author: Gyurin
categories: algorithm
tags: DP 백준
---


## 문제
<a href="https://www.acmicpc.net/problem/11053" target="blank">
  <img src="{{site.baseurl}}/assets/algorithm/BOJ-11053-problem.png" title="[백준] 11053 가장 긴 증가하는 부분 수열">
</a>

## 아이디어
새삼 느끼지만 DP문제는 2가지가 중요한 것 같다. dp[n]을 어떻게 정의할 것인가와 dp값을 정의에 맞게 어떻게 계산할 것인가. 이 문제는 <a href="{{site.baseurl}}/algorithm/2019/07/22/백준-1912.html" target="blank">연속합 문제(1912)</a> 때의 기억으로, dp[i]를 A[i]로 끝나는 가장 긴 부분 수열의 길이로 정의하고 A[i]를 알기 위해 0부터 i-1까지 탐색하면 된다.<br>

1. 변수 <br>
    `const int MAX = 1001`: 반복문에서 편한 처리를 위해 0번째 인덱스를 만들 예정이라 1000+1이다.<br>
    `int A[MAX]`: 인풋으로 받는 수열.<br>
    `int dp[MAX]`: dp[i]는 A[i]로 끝나는 가장 긴 부분수열의 길이를 담는다.<br>
    `int res`: 정답. 수열 전체에서 가장 긴 부분수열의 길이.<br>
    
2. 코드 구성<br>
    1) 입력 처리<br>
        : 0번째는 0으로 채울 예정이라 1번째부터 N번째까지 입력을 받는다.<br>
        
    2) DP 채우기 (bottom-up)<br>
        : dp[i]를 알기위해, 0번째부터 i-1번째까지 돌며 확인한다. len이란 변수를 이용해서, A[j]값이 A[i]보다 작고 len이 dp[j]보다 작거나 같으면, A[j]로 끝나는 가장 긴 증가하는 부분 수열에 A[i]를 추가할 수 있다는 의미이므로 len을 증가시켜준다. 최종 len이 dp[i]가 된다.<br>
        
    3) 정답 업데이트<br>
        : 현재 res값과 새로 채운 dp[i]를 비교하여 큰 값으로 res를 업데이트한다.<br>

    
## 코드
{% highlight c++ linenos=table %}
#include <iostream>
using namespace std;

const int MAX = 1001;
int N, res;
int A[MAX], dp[MAX];    //dp[i]: A[i]로 끝나는 가장 긴 부분수열의 길이

int main(){
    ios::sync_with_stdio(false);
    cin.tie(NULL);  cout.tie(NULL);

    cin >> N;
    for(int i=1; i<=N; i++)
        cin >> A[i];
        
    for(int i=1; i<=N; i++){
        int len = 0;
        for(int j=0; j<i; j++){
            if(A[j]<A[i] && len<=dp[j])
                len++;
        }
        dp[i] = len;
        res = res<len?len:res;
    }
    cout << res << "\n";
    return 0;
}
{% endhighlight %}

## 결과
<img src="{{site.baseurl}}/assets/algorithm/BOJ-11053-result.png" title="[백준] 11053 가장 긴 증가하는 부분 수열"><br><br>
